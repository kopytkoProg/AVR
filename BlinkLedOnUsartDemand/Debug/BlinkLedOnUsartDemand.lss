
BlinkLedOnUsartDemand.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  000001ac  00000240  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001ac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000022  00800110  00800110  00000250  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000250  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000048  00000000  00000000  00000280  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000026c  00000000  00000000  000002c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000001b3  00000000  00000000  00000534  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000001ab  00000000  00000000  000006e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000c8  00000000  00000000  00000894  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001fd  00000000  00000000  0000095c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000016e  00000000  00000000  00000b59  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000038  00000000  00000000  00000cc7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	33 c0       	rjmp	.+102    	; 0x6a <__bad_interrupt>
   4:	32 c0       	rjmp	.+100    	; 0x6a <__bad_interrupt>
   6:	31 c0       	rjmp	.+98     	; 0x6a <__bad_interrupt>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	29 c0       	rjmp	.+82     	; 0x6a <__bad_interrupt>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	27 c0       	rjmp	.+78     	; 0x6a <__bad_interrupt>
  1c:	26 c0       	rjmp	.+76     	; 0x6a <__bad_interrupt>
  1e:	25 c0       	rjmp	.+74     	; 0x6a <__bad_interrupt>
  20:	24 c0       	rjmp	.+72     	; 0x6a <__bad_interrupt>
  22:	23 c0       	rjmp	.+70     	; 0x6a <__bad_interrupt>
  24:	3d c0       	rjmp	.+122    	; 0xa0 <__vector_18>
  26:	46 c0       	rjmp	.+140    	; 0xb4 <__vector_19>
  28:	20 c0       	rjmp	.+64     	; 0x6a <__bad_interrupt>
  2a:	1f c0       	rjmp	.+62     	; 0x6a <__bad_interrupt>
  2c:	1e c0       	rjmp	.+60     	; 0x6a <__bad_interrupt>
  2e:	1d c0       	rjmp	.+58     	; 0x6a <__bad_interrupt>
  30:	1c c0       	rjmp	.+56     	; 0x6a <__bad_interrupt>
  32:	1b c0       	rjmp	.+54     	; 0x6a <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d4 e0       	ldi	r29, 0x04	; 4
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_copy_data>:
  40:	11 e0       	ldi	r17, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	ec ea       	ldi	r30, 0xAC	; 172
  48:	f1 e0       	ldi	r31, 0x01	; 1
  4a:	02 c0       	rjmp	.+4      	; 0x50 <__do_copy_data+0x10>
  4c:	05 90       	lpm	r0, Z+
  4e:	0d 92       	st	X+, r0
  50:	a0 31       	cpi	r26, 0x10	; 16
  52:	b1 07       	cpc	r27, r17
  54:	d9 f7       	brne	.-10     	; 0x4c <__do_copy_data+0xc>

00000056 <__do_clear_bss>:
  56:	21 e0       	ldi	r18, 0x01	; 1
  58:	a0 e1       	ldi	r26, 0x10	; 16
  5a:	b1 e0       	ldi	r27, 0x01	; 1
  5c:	01 c0       	rjmp	.+2      	; 0x60 <.do_clear_bss_start>

0000005e <.do_clear_bss_loop>:
  5e:	1d 92       	st	X+, r1

00000060 <.do_clear_bss_start>:
  60:	a2 33       	cpi	r26, 0x32	; 50
  62:	b2 07       	cpc	r27, r18
  64:	e1 f7       	brne	.-8      	; 0x5e <.do_clear_bss_loop>
  66:	75 d0       	rcall	.+234    	; 0x152 <main>
  68:	9f c0       	rjmp	.+318    	; 0x1a8 <_exit>

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <clear_buffer>:
# define BUFFER_SIZE 32
volatile unsigned int usart_bufor_ind;										//indeks bufora nadawania
char usart_bufor[BUFFER_SIZE];												//bufor nadawania

void clear_buffer(void)
{
  6c:	e0 e1       	ldi	r30, 0x10	; 16
  6e:	f1 e0       	ldi	r31, 0x01	; 1
  70:	80 e3       	ldi	r24, 0x30	; 48
  72:	91 e0       	ldi	r25, 0x01	; 1
	for (int i = 0; i < BUFFER_SIZE; i++ ) usart_bufor[i] = 0;
  74:	11 92       	st	Z+, r1
  76:	e8 17       	cp	r30, r24
  78:	f9 07       	cpc	r31, r25
  7a:	e1 f7       	brne	.-8      	; 0x74 <clear_buffer+0x8>
}
  7c:	08 95       	ret

0000007e <usart_inicjuj>:
//--------------------------------------------------------------
void usart_inicjuj(void)
{

	//ustaw obliczone przez makro wartoœci
	UBRR0H = UBRRH_VALUE;
  7e:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = UBRRL_VALUE;
  82:	83 e3       	ldi	r24, 0x33	; 51
  84:	80 93 c4 00 	sts	0x00C4, r24
	#if USE_2X
	UCSR0A |=  (1<<U2X0);
	#else
	UCSR0A &= ~(1<<U2X0);
  88:	e0 ec       	ldi	r30, 0xC0	; 192
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	80 81       	ld	r24, Z
  8e:	8d 7f       	andi	r24, 0xFD	; 253
  90:	80 83       	st	Z, r24
	#endif
	
	//Ustawiamy pozosta³e parametry modu³ USART
	UCSR0C = (1<<UCSZ01) | (1<<UCSZ00);
  92:	86 e0       	ldi	r24, 0x06	; 6
  94:	80 93 c2 00 	sts	0x00C2, r24
	//bity stopu:  1
	//parzystoœæ:  brak

	//w³¹cz nadajnik i odbiornik oraz ich przerwania odbiornika
	//przerwania nadajnika w³¹czamy w funkcji wyslij_wynik()
	UCSR0B = (1<<TXEN0) | (1<<RXEN0); //| (1<<RXCIE0);
  98:	88 e1       	ldi	r24, 0x18	; 24
  9a:	80 93 c1 00 	sts	0x00C1, r24
  9e:	08 95       	ret

000000a0 <__vector_18>:
}
//--------------------------------------------------------------
ISR(USART_RX_vect)
{
  a0:	1f 92       	push	r1
  a2:	0f 92       	push	r0
  a4:	0f b6       	in	r0, 0x3f	; 63
  a6:	0f 92       	push	r0
  a8:	11 24       	eor	r1, r1
	//przerwanie generowane po odebraniu bajtu
}
  aa:	0f 90       	pop	r0
  ac:	0f be       	out	0x3f, r0	; 63
  ae:	0f 90       	pop	r0
  b0:	1f 90       	pop	r1
  b2:	18 95       	reti

000000b4 <__vector_19>:
//--------------------------------------------------------------
ISR(USART_UDRE_vect)
{
  b4:	1f 92       	push	r1
  b6:	0f 92       	push	r0
  b8:	0f b6       	in	r0, 0x3f	; 63
  ba:	0f 92       	push	r0
  bc:	11 24       	eor	r1, r1
  be:	2f 93       	push	r18
  c0:	3f 93       	push	r19
  c2:	4f 93       	push	r20
  c4:	5f 93       	push	r21
  c6:	6f 93       	push	r22
  c8:	7f 93       	push	r23
  ca:	8f 93       	push	r24
  cc:	9f 93       	push	r25
  ce:	af 93       	push	r26
  d0:	bf 93       	push	r27
  d2:	ef 93       	push	r30
  d4:	ff 93       	push	r31
	
	if(usart_bufor[usart_bufor_ind]!= 0)
  d6:	e0 91 30 01 	lds	r30, 0x0130
  da:	f0 91 31 01 	lds	r31, 0x0131
  de:	e0 5f       	subi	r30, 0xF0	; 240
  e0:	fe 4f       	sbci	r31, 0xFE	; 254
  e2:	80 81       	ld	r24, Z
  e4:	88 23       	and	r24, r24
  e6:	91 f0       	breq	.+36     	; 0x10c <__vector_19+0x58>
	{
		UDR0 = usart_bufor[usart_bufor_ind++];
  e8:	80 91 30 01 	lds	r24, 0x0130
  ec:	90 91 31 01 	lds	r25, 0x0131
  f0:	9c 01       	movw	r18, r24
  f2:	2f 5f       	subi	r18, 0xFF	; 255
  f4:	3f 4f       	sbci	r19, 0xFF	; 255
  f6:	30 93 31 01 	sts	0x0131, r19
  fa:	20 93 30 01 	sts	0x0130, r18
  fe:	fc 01       	movw	r30, r24
 100:	e0 5f       	subi	r30, 0xF0	; 240
 102:	fe 4f       	sbci	r31, 0xFE	; 254
 104:	80 81       	ld	r24, Z
 106:	80 93 c6 00 	sts	0x00C6, r24
 10a:	0a c0       	rjmp	.+20     	; 0x120 <__vector_19+0x6c>
	}
	else
	{
		clear_buffer();
 10c:	af df       	rcall	.-162    	; 0x6c <clear_buffer>
		usart_bufor_ind = 0;
 10e:	10 92 31 01 	sts	0x0131, r1
 112:	10 92 30 01 	sts	0x0130, r1
		UCSR0B &= ~(1<<UDRIE0); //wy³¹cz przerwania pustego bufora nadawania
 116:	e1 ec       	ldi	r30, 0xC1	; 193
 118:	f0 e0       	ldi	r31, 0x00	; 0
 11a:	80 81       	ld	r24, Z
 11c:	8f 7d       	andi	r24, 0xDF	; 223
 11e:	80 83       	st	Z, r24
	}
}
 120:	ff 91       	pop	r31
 122:	ef 91       	pop	r30
 124:	bf 91       	pop	r27
 126:	af 91       	pop	r26
 128:	9f 91       	pop	r25
 12a:	8f 91       	pop	r24
 12c:	7f 91       	pop	r23
 12e:	6f 91       	pop	r22
 130:	5f 91       	pop	r21
 132:	4f 91       	pop	r20
 134:	3f 91       	pop	r19
 136:	2f 91       	pop	r18
 138:	0f 90       	pop	r0
 13a:	0f be       	out	0x3f, r0	; 63
 13c:	0f 90       	pop	r0
 13e:	1f 90       	pop	r1
 140:	18 95       	reti

00000142 <cp_to_buffer>:
//--------------------------------------------------------------
//--------------------------------------------------------------

char* cp_to_buffer(char *s1, const char *s2)
{
 142:	db 01       	movw	r26, r22
 144:	e8 2f       	mov	r30, r24
 146:	f9 2f       	mov	r31, r25
	char *s = s1;
	while ((*s++ = *s2++) != 0);
 148:	2d 91       	ld	r18, X+
 14a:	21 93       	st	Z+, r18
 14c:	21 11       	cpse	r18, r1
 14e:	fc cf       	rjmp	.-8      	; 0x148 <cp_to_buffer+0x6>
	return (s1);
}
 150:	08 95       	ret

00000152 <main>:

int main(void)
{
	// clear buffer
	clear_buffer();
 152:	8c df       	rcall	.-232    	; 0x6c <clear_buffer>
	// set out PB0 (for diode)
	DDRB |= _BV(DDB0);
 154:	20 9a       	sbi	0x04, 0	; 4
	
	usart_inicjuj(); // initialize USART (RS-232)
 156:	93 df       	rcall	.-218    	; 0x7e <usart_inicjuj>
	sei();           // Enables interrupts
 158:	78 94       	sei
	
	while(1){
		if ((UCSR0A & (1<<UDRE0)) && !usart_bufor[0])
 15a:	c0 ec       	ldi	r28, 0xC0	; 192
 15c:	d0 e0       	ldi	r29, 0x00	; 0
 15e:	00 e1       	ldi	r16, 0x10	; 16
 160:	11 e0       	ldi	r17, 0x01	; 1
		{
			cp_to_buffer(usart_bufor, "To jest test \r\n" );
			UCSR0B |= (1<<UDRIE0);
 162:	0f 2e       	mov	r0, r31
 164:	f1 ec       	ldi	r31, 0xC1	; 193
 166:	ef 2e       	mov	r14, r31
 168:	f1 2c       	mov	r15, r1
 16a:	f0 2d       	mov	r31, r0
		}
		PORTB ^= _BV(PB0);
 16c:	dd 24       	eor	r13, r13
 16e:	d3 94       	inc	r13
	
	usart_inicjuj(); // initialize USART (RS-232)
	sei();           // Enables interrupts
	
	while(1){
		if ((UCSR0A & (1<<UDRE0)) && !usart_bufor[0])
 170:	88 81       	ld	r24, Y
 172:	85 ff       	sbrs	r24, 5
 174:	0c c0       	rjmp	.+24     	; 0x18e <main+0x3c>
 176:	f8 01       	movw	r30, r16
 178:	80 81       	ld	r24, Z
 17a:	81 11       	cpse	r24, r1
 17c:	08 c0       	rjmp	.+16     	; 0x18e <main+0x3c>
		{
			cp_to_buffer(usart_bufor, "To jest test \r\n" );
 17e:	60 e0       	ldi	r22, 0x00	; 0
 180:	71 e0       	ldi	r23, 0x01	; 1
 182:	c8 01       	movw	r24, r16
 184:	de df       	rcall	.-68     	; 0x142 <cp_to_buffer>
			UCSR0B |= (1<<UDRIE0);
 186:	f7 01       	movw	r30, r14
 188:	80 81       	ld	r24, Z
 18a:	80 62       	ori	r24, 0x20	; 32
 18c:	80 83       	st	Z, r24
		}
		PORTB ^= _BV(PB0);
 18e:	85 b1       	in	r24, 0x05	; 5
 190:	8d 25       	eor	r24, r13
 192:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 194:	ff ef       	ldi	r31, 0xFF	; 255
 196:	29 e6       	ldi	r18, 0x69	; 105
 198:	88 e1       	ldi	r24, 0x18	; 24
 19a:	f1 50       	subi	r31, 0x01	; 1
 19c:	20 40       	sbci	r18, 0x00	; 0
 19e:	80 40       	sbci	r24, 0x00	; 0
 1a0:	e1 f7       	brne	.-8      	; 0x19a <main+0x48>
 1a2:	00 c0       	rjmp	.+0      	; 0x1a4 <main+0x52>
 1a4:	00 00       	nop
 1a6:	e4 cf       	rjmp	.-56     	; 0x170 <main+0x1e>

000001a8 <_exit>:
 1a8:	f8 94       	cli

000001aa <__stop_program>:
 1aa:	ff cf       	rjmp	.-2      	; 0x1aa <__stop_program>
